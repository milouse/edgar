import os
import yaml
import datetime

from .block import Block
from .errors import EdgarNoConfigFileFoundError
from .formatter import format_block


class Edgar(object):
    """A OpenSSH config file compiler.

Edgar compiles its source file into a valid OpenSSH client config file
and optionally write the results in `~/.ssh/config`.

Edgar expects its source file to be either in `~/.config/edgar.yml` or
in `~/.edgarrc`.  This source file must be a valid YAML document.  A
specific source file can be given with the `config_file` argument.

You can specifies the OpenSSH client config file name to use with
`output_file` argument.  It defaults to `~/.ssh/config`.  If the value
`-` is given, the result will be printed on the standard output."""
    def __init__(self, config_file=None, output_file=None):
        self.config_file = self.prepare_config_file(config_file)
        self.output = self.prepare_output(output_file)

        with open(self.config_file, "r") as f:
            conf = yaml.safe_load(f) or {}
        self.config = {}
        self.parse(conf)

    def __str__(self):
        return self.stringify()

    def compile_time(self):
        return datetime.datetime.utcnow().isoformat()

    def write(self):
        if self.output == "-":
            print(self.stringify())
            return
        header = """# Generated by Edgar on {date}
#
# Be aware that any manual change to it may be overwritten.
# Source: {source}

""".format(date=self.compile_time(),
           source=self.config_file)
        outputdir = os.path.dirname(self.output)
        if outputdir != "" and not os.path.exists(outputdir):
            os.mkdir(outputdir)
        with open(self.output, "w") as f:
            f.write(header)
            f.write(self.stringify() + "\n")

    def parse(self, hosts, config={}):
        if isinstance(hosts, list):
            for h in hosts:
                c = config.copy()
                if isinstance(h, str):
                    # We are only dealing with a list of hostname
                    c.update({"Host": h})
                else:
                    c.update(h)
                self.parse_block(c)
            return
        self.parse_block(hosts)

    def prepare_config_file(self, config_file):
        candidates = ["~/.config/edgar.yml", "~/.edgarrc"]
        if config_file is not None:
            candidates.insert(0, config_file)

        for f in candidates:
            conffile = os.path.expanduser(f)
            if os.path.exists(conffile):
                return conffile

        raise EdgarNoConfigFileFoundError(
            "None of the following has been found: {}".format(
                ", ".join(candidates)
            )
        )

    def prepare_output(self, output):
        if not output:
            output = "~/.ssh/config"
        if output == "-":
            return "-"
        return os.path.expanduser(output)

    def stringify(self):
        content = []
        defaults = self.config.pop("Host *", None)
        for header, body in self.config.items():
            content.append(format_block(header, body))
        if defaults is not None:
            content.append(format_block("Host *", defaults))
        return "\n\n".join(content).strip()

    def store_block(self, block):
        if block.get("hide"):
            return
        name = block.header()
        if name not in self.config:
            self.config[name] = set()
        self.config[name] |= block.body()

    def process_block(self, block_options):
        block = Block(block_options)
        self.store_block(block)
        subblocks = block.get("blocks", []) or []
        if len(subblocks) == 0:
            return
        self.parse(subblocks, block.children_config())

    def parse_block(self, block_options):
        with_items = block_options.pop("with_items", [None])
        if isinstance(with_items, str):
            loopiterator = eval(with_items)
        else:
            loopiterator = with_items
        for item in loopiterator:
            block_options["item"] = item
            self.process_block(block_options.copy())
